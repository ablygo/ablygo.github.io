
I believe Idris has a syntax like

```
do
    Just x <- foo | Nothing => ...1
    ...2
```

which simply is sugar around a case statement, rearranging terms so that everything in `...2` is part of the `Just x` pattern match clause. I kind of want this, though I don't view it as a huge priority. I was actually coming up with a syntax for something else, and while coming up with semantics for it realized it could potentially work well together with this, so here are my thoughts.

The syntax was in allowing `x : ...` and `x = ...` in statements. Both present some ambiguity with records, though records and blocks can be distinguished with the choice of comma or semicolon, and 1-records have leading commas, so it doesn't cause true ambiguity. Though I may use oxford brackets for blocks to remove the issue anyway.

How this relates to the Idris syntax was due to coming up with semantics for `x = ...`. One thing that the `let` in a do block denotes is the scope of recursive bindings, so if you had multiple assignments it would be unclear if they should be recursive. My decision was that trying to be smart here would be bad, and to simply make them non-recursive, maybe with an exception for (syntactic) function definitions, so that `f x = f x` would be resursive (though `f = \x -> f x` would not). I don't know if that exception is worth it though.

Where it relates to Idris's syntax was deciding if you could pattern match in an assignment, and I realized it would be perfectly sensible if you desugared it as:

```
Just x = ...1         case ...1 of
...2                       Just x => ...2
```

This makes the fact that it's non-recursive more obvious, but then gives question to what you should do if the pattern match fails. Stealing Idris's syntax, we could write

```
Just x = ...1
    | _ => ...3
...2
```

Which avoids increasing indentation on the good path, while still defining the bad path. This solves a few issues which I was surprised to realize, such as having the desire for a non-recursive let. We could simply use do-notation, and assignment, and if no `<-` were present it would desugar exactly how we would think.

We could even use the same syntax for pattern matching in let/where bindings, where the return type of the bad path has to be the same as the return type in the body to which the declarations are bound. This would however force an evaluation order on the declarations, which we don't really think of normally when using let/where (I believe an evaluation order does currently exist if you use refutable pattern matches in declarations, but having syntax that makes people rely on that even more seems like a bad design).

Another option, which I like for its simplicity, is to have strict let like:

```haskell
let #![StrictLet]
    x = ...
in
```

I would prefer this for strict bindings. I do still like the idea of the syntax in do-blocks for the problem of good/bad paths (since sequentialization of bindings is already implied), but the annotation-based syntax does remove the side-benefit of filling the need for strict let.

The big issue with this syntax is the use of `|`, which is also used in guards. Making guards follow layout would remove this issue, as you could write

```haskell
f x y
  | x == y = do
      Just x <- x
          | Nothing => y
      pure ()
  | otherwise = pure y
```

With layout which characters are guards and which define bad paths is unambiguous. The ambiguity is when you can write code like ```f x y | x == y = ... | otherwise = ...```. Here the `|` in guards can't be disambiguated from `|` which may appear in an expression. I do want to find a way to resolve this issue, but would prefer to avoid needing guards to be indentation sensitive if I can, even if my preferred style is indentation sensitive in a way that resolves the ambiguity. 

Another ambiguity that using `:` in do blocks is due to determining whether we're providing a type signature for the following variable, or giving the type of the preceding expression. I'm considering disallowing `:` to provide types to expressions like Idris, which does solve the issue, though the fact I also require newly introduced variables to be ticked does resolve the ambiguity (though perhaps in an easily missed way).
